Основные классы-реализации InputStream (потоки ввода):
    - ByteArrayInputStream - читает байты из массива
    - FileInputStream - читает данные из файла
    - ObjectInputStream - поток ввода объектов
    - PipedInputStream - канал ввода
    - FilterInputStream - реализует класс InputStream. От него реализуются следующие 3 класса: 
            - BufferedInputStream - буферизированный поток ввода  
            - DataInputStream - читает данные примитивных типов
            - PushbackInputStream - поток ввода, поддерживающий возврат одного байта обратно в поток ввода    


Основные классы-реализации OutputStream (потоки вывода):
    - ByteArrayOutputStream - записывает байты в массив
    - FileOutputStream - записывает данные в файл
    - ObjectOutputStream - поток вывода объектов
    - PipedOutputStream - канал вывода
    - PrintStream - поток вывода, содержащий методы print() и println()
    - FilterOutputStream - реализует класс OutputStream. От него реализуются следующие 2 класса:  
            - BufferedOutputStream - буферизированный поток вывода  
            - DataOutputStream - записывает данные примитивных типов  

**Важно!** Все классы, имеющие в названии InputStream/OutputStream читают/пишут данные **побайтово**.


Основные классы-реализации Reader (потоки ввода символов):
    - BufferedReader - буферизированный поток ввода символов
    - CharArrayReader - читает символы из массива
    - PipedReader - канал ввода
    - StringReader - читает символы из строки
    - FilterReader - фильтрованный поток чтения. От этого класса наследуется класс PushbackReader:
            - PushbackReader - поток ввода, позволяющий вернуть считанные символы обратно в поток ввода
    - InputStreamReader - преобразует байты в символы. От этого класса наследуется класс FileReader:
            - FileReader - читает символы из файла  
  

Основные классы-реализации Writer (потоки вывода символов):
    - BufferedWriter - буферизированный поток вывода символов
    - CharArrayWriter - записывает символы в массив
    - PipedWriter - канал вывода
    - StringWriter - записывает символы в строку
    - FilterWriter - фильтрованный поток записи. 
    - PrintWriter - поток вывода, содержащий методы print() и println()  
    - OutputStreamWriter - преобразует символы в байты. От этого класса наследуется класс FileWriter:- 
            - FileWriter - записывает символы в файл

Все приложения Java автоматически импортируют пакет java.lang. Класс System этого пакета содержит свойства исполняющей среды Java. В том числе он содержит три _предопределенных_ потока ввода-вывода: in, out и err. Эти переменные можно использовать в любой части программы.
System.out - ссылается на стандартный поток вывода (консоль). 
System.in - ссылается на стандартный поток ввода (клавиатура). 
System.err - ссылается на стандартный поток вывода ошибок (консоль). 

Переменные out и err содержат внутри объект типа PrintStream, а переменная in содержит внутри объект типа InputStream.

Ниже представлена вся иерархия классов и интерфейсов пакета java.io:

![[Pasted image 20250625175444.png]]


**NIO.**

В версии Java 1.4 была введена новая система ввода-вывода - NIO (New IO). Она представлена в пакете java.nio. В данном уроке мы коротко рассмотрим ее основные отличия от ранее рассмотренной системы ввода-вывода Java IO (пакет java.io).

Новая система Java NIO API использует _буферориентированный_ подход. Данный подход организует чтение и запись данных с помощью их загрузки в специальные буферы, внутри которых можно перемещаться по данным вперед и назад, тем самым обеспечивается гибкость обработки данных. 

Есть еще одно отличие между IO и NIO:

- в IO при чтении из потока или записи в поток (методы read или write) работа программы блокируется, пока не закончится чтение/запись. Данные читаются побайтово или посимвольно.

- NIO читает данные в буфер. Обработать можно только те данные, которые уже считались в буфер. При этом блокировка программы не производится.

 В основе системы ввода-вывода NIO лежат буферы и каналы. Буфер хранит данные, а канал - это шлюз, который предоставляет соединение с устройством ввода-вывода (Например, файл). Система работы NIO: получаем буфер для хранения данных, получаем канал для устройства ввода-вывода.

**NIO.2.**

В Java 7 система ввода-вывода NIO была значительно расширена (данное обновление также называют NIO.2). Были добавлены несколько пакетов и классов, направленных на расширение возможностей применения системы ввода-вывода NIO. Отдельно можно выделить пакет java.nio.file, его интерфейс Path и классы Paths, Files, которые расширяют возможности манипуляции с файлами (файловый ввод-вывод).


**Буферизированный поток** - это стандартный поток, к которому добавлен специальный буфер в памяти, который увеличивает производительность чтения и записи. Обращение к ресурсу при чтении/записи - это очень затратный процесс, поэтому чем меньше обращений к ресурсу - тем лучше. Буферизированные потоки - это обёртки обычных потоков с буфером.
Буфер выгоден тем, что при записи данных на диск, данные не пишутся непосредственно на ресурс (диск), а сохраняются в буфере потока. В этом случае данные будут записаны на диск либо при закрытии потока, либо при явном вызове метода flush(), который переводит накопленные буфером данные в поток.
Буферное побайтовое чтение/запись реализовано классами BufferedInputStream и BufferedOutputStream.
Буферное посимвольное чтение/запись реализовано классами BufferedReader и BufferedWriter.
Все buffered* классы являются обёртками и не могут существовать сами по себе. При создании объектов этих классов в их конструкторы нужно передавать объекты классов-реализаций InputStream/OutputStream. Могут быть и цепочки обёрток, но в корне всегда должен быть байтовый или символьный поток.

import java.io.BufferedInputStream;
import java.io.BufferedOutputStream;
import java.io.FileInputStream;
import java.io.FileOutputStream;

public class Buffered {
    public static void main(String[] args) {
        try (BufferedInputStream input = new BufferedInputStream(new FileInputStream("data/input.txt")); 
             BufferedOutputStream output = new BufferedOutputStream(new FileOutputStream("data/output.txt"))) {
                output.write(input.readAllBytes());
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}

Чтобы метод write() добавлял данные в файл, а не перезаписывал, нужно использовать такой конструктор:
FileOutputStream(String name, boolean append)

В заключение можно сказать, что в уроках по IO в показательных целях могут применяться различные байтовые и символьные потоки для чтения различных типов данных, но нужно запомнить важный момент: если нужно работать только с текстовыми (символьными) данными, то рекомендуется использовать символьные потоки и их обёртки (*Reader / *Writer), а если данные имеют байтовый или смешанный вид, то рекомендуется применять байтовые потоки и их обёртки (*InputStream / *OuputStream). Это важно не только с точки зрения производительности, но и с точки зрения целостности данных. Например, нельзя прочитать файл png символьным потоком, так как *.png файл содержит только байтовые данные, которые невозможно привести к символам.

