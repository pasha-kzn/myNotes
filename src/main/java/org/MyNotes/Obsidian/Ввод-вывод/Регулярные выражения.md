_Регулярные выражения_ (Regular Expressions или RegEx) - это шаблоны, с помощью которых производится поиск по совпадению в тексте. То есть это строка, описывающая последовательность символов, которую желаем найти. С помощью определенного синтаксиса искать можно не только символы напрямую, но и целые диапазоны или комбинации символов. Тем самым можно создавать самые разнообразные шаблоны для поиска с помощью последовательности обычных символов, метасимволов и квантификаторов (о метасимволах и квантификаторах будет рассказано в следующем уроке). В Java работа с регулярными выражениями производится с помощью классов Pattern и Matcher из пакета java.util.regex. Эти классы работают в паре. В классе Pattern определяется регулярное выражение (создается шаблон и сопоставитель), а с помощью класса Matcher производится сопоставление шаблона с текстом.

`import java.util.regex.Matcher;`
`import java.util.regex.Pattern;`

`public class RegexExample {`
    `public static void main(String[] args) {`
        `Pattern pattern = Pattern.compile("Я учусь на Job4j");` 

        `String textOne = "Я учусь на Job4j";` 
        `Matcher matcherOne = pattern.matcher(textOne);` 
        `boolean isPresentOne = matcherOne.matches();` 
        `System.out.println(isPresentOne);` 

        `String textTwo = "Я учусь на курсе Job4j";` 
        `Matcher matcherTwo = pattern.matcher(textTwo);` 
        `boolean isPresentTwo = matcherTwo.matches();` 
        `System.out.println(isPresentTwo);` 
    `}`
`}`

Вывод:
true
false

Регулярные выражения **регистрозависимые**. Буквы ищутся в том регистре, в котором они написаны. В следующем коде шаблон "Job4j" сверяется с вариантами такого же текста, начинающегося со строчной и прописной букв.

Если регистр букв при поиске не принципиален, можно вместе с текстом шаблона передать в метод compile() параметр в виде статической константы Pattern.CASE_INSENSITIVE, определенной в классе Pattern. Теперь при поиске совпадений регистр букв учитываться не будет
`Pattern pattern = Pattern.compile("Job4j", Pattern.CASE_INSENSITIVE);` 

Также можно проверить шаблон на его присутствие в тексте. Проверка выполняется с помощью метода find() класса Matcher.
`boolean isPresent = matcher.find();` 

Метод find() ищет ближайшее совпадение. Его можно применять многократно. Каждый вызов метода find() начинается с места, где закончился его предыдущий вызов. Чтобы найти многократные вхождения шаблона в коде, нужно использовать find() в цикле.

Получить найденное совпадение в виде строки можно с помощью метода group(). Этот метод выводит ту часть текста, которая совпадает с шаблоном регулярного выражения. В данном случае это "Job4j".

`import java.util.regex.Matcher;`
`import java.util.regex.Pattern;`

`public class RegexExample {`
    `public static void main(String[] args) {`
        `Pattern pattern = Pattern.compile("Job4j");` 
        `String text = "Job4j1 и Job4j2 и Job4j3";` 
        `Matcher matcher = pattern.matcher(text);` 
        `while (matcher.find()) {` 
            `System.out.println("Найдено совпадение: " + matcher.group());` 
        `}`
    `}`
`}`

Также существуют методы получения начального и конечного индексов найденного совпадения.
Метод start() - получает индекс, в котором находится первый символ искомой последовательности символов.
Метод end() - получает индекс, следующий **за** последним символом искомой последовательности символов.

Найденные совпадения можно заменить другой строкой с помощью метода replaceAll(), который применяется к сопоставителю matcher.

`import java.util.regex.Matcher;`
`import java.util.regex.Pattern;`

`public class RegexExample {`
    `public static void main(String[] args) {`
        `Pattern pattern = Pattern.compile("123");` 
        `String text = "1231 и 1232 и 1233";` 
        `Matcher matcher = pattern.matcher(text);` 
        `String result = matcher.replaceAll("Job4j");` 
        `System.out.println(result);` 
    `}`
`}`

Применение - подробно на https://job4j.ru/exercise/45/task-view/998

**Метасимвол**

**Метасимвол** - это символ или последовательность символов, имеющие специальное назначение. Метасимволов и их комбинаций существует много, в этом уроке будут показаны только основные. 
Сайт [regex101.com](https://regex101.com/) - для проверки.  Синим на скриншотах отображаются найденные последовательности символов (их еще называют вхождения). Чередующиеся оттенки синего - это _разные_ найденные последовательности. Например, на скриншоте ниже найдено 3 последовательности символов "11". Они разделены разными оттенками синего.
Запрос в окне "Regular expression" и входящий текст в окне "Test string" аналогичны шаблону (pattern) и строке (text) для сравнения в Java.

![[Pasted image 20250626085542.png]]

**1) Позиционные метасимволы.**

**^** - начало строки
**^** - начало строки 
**\b** - граница слова 
**\B** - не граница слова

![[Pasted image 20250626090622.png]]

**2) Метасимволы группировки (символьные классы).** Определяют диапазоны символов.

**[abc]** - символ(ы) или диапазон символов. Каждый проверяемый в тексте символ проверяется на присутствие в заданном диапазоне. **Важно!** Каждая из записей в квадратных скобках [] относится к одному символу. То есть при данной записи [abc] каждый символ текста будет оцениваться на предмет является ли он a, b или c. В данном случае текст делится на литералы, состоящие из одного символа.
**[^abc]** - все символы, кроме перечисленных
**[a-сx-z]** - объединение диапазонов. В данной записи совмещены диапазоны а-с и x-z. Запись может содержать и одиночные символы.
[^a-сx-z] - все символы, кроме входящих в данные диапазоны. Противоположность предыдущему варианту [a-сx-z]. Запись также может содержать и одиночные символы.

![[Pasted image 20250626090915.png]]

**Метасимволы группы литералов.**

**.** (точка) - любой символ.
**\d** - любой цифровой символ.
**\D -** любой символ, кроме цифровых.
**\s** - символ пробела.
**\S** - все символы, кроме пробела.
**\w** - символ буквы, цифры или символ подчеркивания.
**\W** - любой символ, кроме буквы, цифры и символа подчеркивания.

![[Pasted image 20250626091316.png]]

**Метасимволы редактирования текста.**

**\n** - символ новой строки.
**\r** - символ возврата каретки в начало строки.
**\t** - символ табуляции.

![[Pasted image 20250626094253.png]]

**Квантификаторы.**
**Квантификатор** - это метасимвол, который обозначает количество вхождений символа и _всегда ставится после него_. При использовании квантификаторов находится не только одиночный символ, но и последовательность символов (кроме нулевых вхождений).

\* - ноль или более раз
  Находятся не только все вхождения, но и все нулевые вхождения (подсвечены фиолетовым). Нулевые совпадения называются "совпадения нулевой длины". Индекс начала и конца такого совпадения всегда одинаковый.
**+** - один или более раз
**?** - один или отсутствует
**{x}** - х раз
**{x,}** - х раз и более. Т.е. символ должен встречаться не меньше х раз подряд
**{x,y}** - от х до y раз (оба включительно).

![[Pasted image 20250626095105.png]]

**Режимы квантификаторов.**

**Жадный (greedy) режим.**
Все квантификаторы по умолчанию работают в жадном режиме. Его работа заключается в том, что всегда ищется максимально длинное совпадение.

Далее все режимы квантификаторов будут рассматриваться на примере квантификатора "**+**".
В примере ниже условие поиска - это число, начинающееся на 1, оканчивающееся на 3, а серединой является любая цифра от одного раза.

Как мы видим из примера, жадный режим нашел _одно_ совпадение в виде самого длинного совпадения по шаблону, несмотря на то, что в строке есть 2 совпадения, подходящих под шаблон: 1222223 и 12223. То есть при пересечении совпадений будет выбираться самое длинное. Жадный режим идет по символам, пока они удовлетворяют условию (любой цифровой символ), а после достижения неудовлетворяющего символа или конца строки, начинается поиск следующего элемента в обратном направлении, пока не найдется ближайший подходящий символ, следующий в шаблоне. В нашем случае это цифра 3. То есть в примере жадный режим сначала захватил часть строки от единицы до конца, а потом при обратном проходе нашел цифру 3, подходящую под шаблон, в результате была найдена самая длинная удовлетворяющая шаблону последовательность. 

В данном режиме часть строки, следующая за найденной последовательностью, доступна к поиску следующей последовательности.  

Ниже приведен пример, где в строке есть 4 совпадения с шаблоном, но найдены только 2 самых длинных из них.

![[Pasted image 20250626095637.png]]

**Сверхжадный (possessive) режим.**
Записывается в виде символа "**+**" **после** квантификатора. Работает так же, как и жадный режим, но не имеет обратного прохода. 

В примере ниже не найдено совпадений, так как сверхжадный режим захватил всю оставшуюся после единицы строку и не оставил символов для поиска оставшейся в шаблоне цифры 3.

![[Pasted image 20250626095838.png]]

**Ленивый (reluctant) режим.**

Записывается в виде символа "**?**" после квантификатора. Ленивый режим ищет самую короткую последовательность.

В примере ниже используется шаблон для поиска числа, начинающегося на 1, заканчивающегося на 3, а серединой является любая цифра от одного раза.
Ленивый режим сначала найдёт 1, а затем после первого совпадения с квантификатором(символ 2) сразу перейдет к проверке следующего символа (символ 3). Если же следующий символ не совпадает с шаблоном, то продолжается поиск по квантификатору так же по одному символу, пока не найдется совпадение со следующим символом. В результате найдется число 123 и начнется поиск следующих совпадений - 122223 и 1223. То есть будет найдено 3 совпадения.
**Важно!** Символы, используемые в метасимволах, являются частью синтаксиса регулярных выражений, и при создании регулярного выражения будут расцениваться компилятором именно как метасимволы. Если требуется использовать такие символы как обычные символы, нужно их экранировать. 
или нужно найти часть пути с применением слэша "**/**" и точки "**.**":

![[Pasted image 20250626100830.png]]

**String.split()**

Также регулярные выражения можно использовать в виде разделителя в методе split() класса String.
Регулярное выражение "**\\D+**" значит "любой нецифровой символ от одного раза".

`import java.util.Arrays;`

`public class RegexExample {`
    `public static void main(String[] args) {`
       `String string = "123+=-456:/789";`
       `String[] result = string.split("\\D+");`
       `System.out.println(Arrays.toString(result));`
    `}`
`}`

Вывод
\[123, 456, 789\]