**побайтово!**

`package ru.job4j.io;`

`import java.io.FileInputStream;`

`public class ReadFile {`
    `public static void main(String[] args) {`
        `try (FileInputStream input = new FileInputStream("data/input.txt")) {`
            `StringBuilder text = new StringBuilder();`
            `int read;`
            `while ((read = input.read()) != -1) {`
                `text.append((char) read);`
            `}`
            `System.out.println(text);`
        `} catch (IOException e) {`
            `e.printStackTrace();`
        `}`
    `}`
`}`



`import java.io.ByteArrayInputStream;`

`public class ByteArrayStream {`

    `public static void main(String[] args) {`
        `byte[] bytes = new byte[] {'J', 'a', 'v', 'a'};`
        `ByteArrayInputStream stream = new ByteArrayInputStream(bytes);`
        `int data;`
        `while ((data = stream.read()) != -1) {`
            `System.out.print((char) data);`
        `}`
    `}`
`}`
Также считывать данные из массива можно не целиком. Для этого у класса ByteArrayInputStream есть следующий конструктор:
[![](https://job4j.ru/api/images/imageTaskPreview?imageId=85114)](https://job4j.ru/api/images/imageTaskSource?imageId=85114)
Помимо массива байтов, который мы передавали в предыдущем примере, в этот конструктор передаются ещё параметры offset (позиция, с которой начнется считывание) и length (сколько байтов нужно считать).


try (BufferedReader input = new BufferedReader(new FileReader("data/input.txt"))) {
            input.lines().forEach(System.out::println);
        } catch (IOException e) {
            e.printStackTrace();
        }

Символьные потоки позволяют читать сразу символы, а не байты. Так же у буферизированного символьного потока есть методы чтения целой строки.

